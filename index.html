<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MONITOR DE LOGS - SISTEMA</title>
    <!-- Vers√£o atualizada -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            color: #00ff00;
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            background: #0a0a0a;
            width: 100%;
            height: calc(100vh - 60px);
            position: relative;
            padding: 8px;
            overflow: hidden;
        }

        h3 {
            color: #00ff00;
            font-size: 14px;
            font-weight: 400;
            padding: 10px 15px;
            border-bottom: 1px solid #00ff00;
            background: #000000;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }


        .card {
            position: absolute;
            display: flex;
            flex-direction: column;
            border: 1px solid #00ff00;
            background: #000000;
            overflow: hidden;
        }


        #card-logs {
            top: 5px;
            left: 5px;
            width: calc(33.33% - 7px);
            height: calc(100% - 10px);
        }

        #card-terminal {
            top: 5px;
            left: calc(33.33% + 3px);
            width: calc(33.33% - 7px);
            height: calc(100% - 10px);
        }

        #card-terminal2 {
            top: 5px;
            left: calc(66.66% + 3px);
            width: calc(33.33% - 8px);
            height: calc(100% - 10px);
        }


        .card-header {
            background: #000000;
            color: #00ff00;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 1px;
            border-bottom: 1px solid #00ff00;
        }

        .card-content {
            flex: 1;
            overflow: auto;
            background: #000000;
        }

        .btn-fullscreen {
            background: transparent;
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 6px 14px;
            font-size: 11px;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            font-weight: 500;
            cursor: pointer;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            border-radius: 2px;
        }

        .btn-fullscreen:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.6);
            color: #00ff00;
            border-color: #003300;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6);
            transform: scale(1.05);
        }

        .card-content {
            position: relative;
            overflow: hidden;
        }

        #logs {
            background: #000000;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px !important;
            line-height: 1.5;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            color: #00ff00;
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            /* Esconder barra padr√£o */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
            /* Otimiza√ß√µes para evitar piscar */
            will-change: contents;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* Esconder barra padr√£o no Webkit */
        #logs::-webkit-scrollbar {
            display: none;
        }

        /* Barra de rolagem customizada - escondida pois usamos CSS animations */
        .custom-scrollbar {
            display: none;
        }

        .custom-scrollbar-track {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000000;
            border-left: 2px solid #003300;
            box-shadow: inset 0 0 10px rgba(0, 51, 0, 1);
        }

        .custom-scrollbar-thumb {
            position: absolute;
            left: 2px;
            right: 2px;
            background: #00ff00;
            background-image: linear-gradient(180deg, #00ff00 0%, #00aa00 50%, #00ff00 100%);
            border-radius: 5px;
            border: 1px solid #003300;
            box-shadow: 
                0 0 15px rgba(0, 255, 0, 1),
                inset 0 0 8px rgba(0, 255, 0, 0.5),
                0 0 25px rgba(0, 255, 0, 0.4);
            min-height: 40px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .custom-scrollbar-thumb:hover {
            background: #00ff00;
            background-image: linear-gradient(180deg, #00ff00 0%, #00ff00 50%, #00ff00 100%);
            box-shadow: 
                0 0 25px rgba(0, 255, 0, 1.2),
                inset 0 0 12px rgba(0, 255, 0, 0.8),
                0 0 40px rgba(0, 255, 0, 0.6);
            border-color: #00ff00;
        }

        /* Barra de rolagem customizada - Tentativa mais agressiva */
        #logs::-webkit-scrollbar {
            width: 12px;
            height: 12px;
            background-color: #000000;
            border-left: 2px solid #003300;
        }

        #logs::-webkit-scrollbar-track {
            background: #000000;
            border-left: 2px solid #003300;
            box-shadow: inset 0 0 8px rgba(0, 51, 0, 0.8);
        }

        #logs::-webkit-scrollbar-thumb {
            background: #00ff00;
            background-image: linear-gradient(180deg, #00ff00 0%, #00aa00 50%, #00ff00 100%);
            border-radius: 6px;
            border: 2px solid #003300;
            box-shadow: 
                0 0 10px rgba(0, 255, 0, 0.8),
                inset 0 0 5px rgba(0, 255, 0, 0.4),
                0 0 20px rgba(0, 255, 0, 0.3);
            min-height: 40px;
        }

        #logs::-webkit-scrollbar-thumb:hover {
            background: #00ff00;
            background-image: linear-gradient(180deg, #00ff00 0%, #00ff00 50%, #00ff00 100%);
            box-shadow: 
                0 0 20px rgba(0, 255, 0, 1),
                inset 0 0 8px rgba(0, 255, 0, 0.6),
                0 0 30px rgba(0, 255, 0, 0.5);
            border-color: #00ff00;
        }

        #logs::-webkit-scrollbar-thumb:active {
            background: #00ff00;
            box-shadow: 
                0 0 25px rgba(0, 255, 0, 1.2),
                inset 0 0 10px rgba(0, 255, 0, 0.8),
                0 0 40px rgba(0, 255, 0, 0.6);
        }

        #logs::-webkit-scrollbar-corner {
            background: #000000;
        }

        #terminal,
        #terminal2,
        .terminal-output {
            background: #000000;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px !important;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            color: #00ff00;
            margin: 0;
        }

        /* Barra de rolagem estilizada para terminal - Webkit */
        #terminal::-webkit-scrollbar,
        #terminal2::-webkit-scrollbar,
        .terminal-output::-webkit-scrollbar {
            width: 6px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #000000;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: #00ff00;
        }

        .loading {
            color: #00ff00;
            animation: blink 1s infinite;
        }

        .error {
            color: #ff0000;
        }

        .empty {
            color: #00ff00;
        }

        .refresh-btn {
            background: transparent;
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 12px 24px;
            font-size: 14px;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            font-weight: 500;
            cursor: pointer;
            margin-top: 15px;
            text-transform: uppercase;
            border-radius: 2px;
            transition: all 0.3s ease;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .refresh-btn:hover {
            background: #000000;
            color: #00ff00;
        }

        .refresh-btn:active {
            background: #003300;
        }

        .refresh-btn:disabled {
            background: #003300;
            color: #005500;
            border-color: #005500;
            cursor: not-allowed;
        }


        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Removido efeito visual */
        body::after {
            content: '';
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.03) 0px,
                rgba(0, 255, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <h3>
        TERMINAIS DE MONITORAMENTO 
        <a href="dashboards.html" style="float: right; margin-right: 20px; color: #D4AF37; text-decoration: none; font-size: 12px; border: 1px solid rgba(212, 175, 55, 0.3); padding: 4px 12px; border-radius: 3px; font-weight: 400;">üìä DASHBOARDS</a>
        <span id="autoRefreshStatus" style="font-size: 12px; float: right; color: rgba(212, 175, 55, 0.7); font-weight: 400;">‚Üª 10s</span>
    </h3>

    <div class="container">
        <!-- Card de Logs -->
        <div id="card-logs" class="card">
            <div class="card-header">
                <span>[1] METAS DI√ÅRIAS</span>
            </div>
            <div class="card-content">
                <pre id="logs" class="loading">Inicializando sistema... Aguarde...</pre>
            </div>
        </div>

        <!-- Card Terminal -->
        <div id="card-terminal" class="card">
            <div class="card-header">
                <span>[2] SALDO EM CONTA</span>
            </div>
            <div class="card-content">
                <pre id="terminal" class="terminal-output">> TERMINAL PRONTO
> Aguardando comandos...
> Sistema operacional...
> 
> _</pre>
            </div>
        </div>

        <!-- Card Terminal 2 -->
        <div id="card-terminal2" class="card">
            <div class="card-header">
                <span>[3] DISCADOR</span>
            </div>
            <div class="card-content">
                <pre id="terminal2" class="terminal-output">> TERMINAL PRONTO
> Aguardando comandos...
> Sistema operacional...
> 
> _</pre>
            </div>
        </div>
    </div>

    <script>
        const API_RELATIVE = "/api/logs"; // endpoint serverless na Vercel
        const API_FALLBACK = "https://auwb72k75qnn3ncgrchc6qpyv40kvdaa.lambda-url.sa-east-1.on.aws/"; // fallback direto
        const LOCAL_PROXY = "http://localhost:9000/api/logs"; // proxy local opcional
        const logsElement = document.getElementById("logs");

        // Fun√ß√£o para fazer requisi√ß√£o com timeout
        function fetchWithTimeout(url, options = {}, timeout = 10000) {
            return Promise.race([
                fetch(url, options),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Timeout')), timeout)
                )
            ]);
        }

        // Fun√ß√£o para fazer requisi√ß√£o tentando serverless /api/logs (Vercel/Netlify), depois local proxy e fallback direto
        async function fazerRequisicao(url) {
            // 1. Serverless (Vercel) - mesmo dom√≠nio, sem CORS
            try {
                console.log("Tentando /api/logs (serverless Vercel)...");
                const resp = await fetchWithTimeout(API_RELATIVE, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                }, 10000);
                if (resp.ok) {
                    const data = await resp.json();
                    console.log("‚úÖ /api/logs (Vercel) funcionou!");
                    return data;
                }
            } catch (err) {
                console.log("Falha em /api/logs (Vercel):", err.message);
            }
            
            // 1.5. Serverless (Netlify) - tentar fun√ß√£o Netlify
            try {
                console.log("Tentando /.netlify/functions/logs (Netlify)...");
                const netlifyResp = await fetchWithTimeout('/.netlify/functions/logs', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                }, 10000);
                if (netlifyResp.ok) {
                    const data = await netlifyResp.json();
                    console.log("‚úÖ /.netlify/functions/logs (Netlify) funcionou!");
                    return data;
                }
            } catch (err) {
                console.log("Falha em /.netlify/functions/logs (Netlify):", err.message);
            }

            // 2. Proxy local (√∫til para desenvolvimento)
            try {
                console.log("Tentando servidor proxy local...");
                const localResponse = await fetchWithTimeout(LOCAL_PROXY, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                }, 3000); // Timeout curto para detectar se est√° dispon√≠vel
                
                if (localResponse.ok) {
                    const data = await localResponse.json();
                    console.log("‚úÖ Servidor proxy local funcionou!");
                    return data;
                }
            } catch (localErr) {
                console.log("Servidor proxy local n√£o dispon√≠vel:", localErr.message);
            }

            // 3. Tenta requisi√ß√£o direta (fallback)
            try {
                console.log("Tentando requisi√ß√£o direta...");
                const directResponse = await fetchWithTimeout(API_FALLBACK, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    mode: 'cors'
                }, 10000);
                
                if (directResponse.ok) {
                    const data = await directResponse.json();
                    console.log("‚úÖ Requisi√ß√£o direta funcionou!");
                    return data;
                }
            } catch (directErr) {
                console.log("Requisi√ß√£o direta falhou:", directErr.message);
            }

            // 3. Tenta proxies p√∫blicos como √∫ltimo recurso
            const proxies = [
                {
                    name: 'allorigins',
                    url: `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
                    parse: async (response) => {
                        const data = await response.json();
                        if (data.contents) {
                            return JSON.parse(data.contents);
                        }
                        throw new Error("Resposta vazia do proxy");
                    }
                }
            ];

            for (const proxy of proxies) {
                try {
                    console.log(`Tentando proxy p√∫blico: ${proxy.name}...`);
                    
                    const proxyResponse = await fetchWithTimeout(proxy.url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        }
                    }, 20000); // 20 segundos de timeout
                    
                    if (!proxyResponse.ok) {
                        throw new Error(`Erro ${proxyResponse.status}: ${proxyResponse.statusText}`);
                    }
                    
                    const parsedData = await proxy.parse(proxyResponse);
                    console.log(`‚úÖ Proxy ${proxy.name} funcionou!`);
                    return parsedData;
                    
                } catch (err) {
                    console.warn(`‚ùå Proxy ${proxy.name} falhou:`, err.message);
                    continue;
                }
            }

            // Se tudo falhou
            throw new Error("N√£o foi poss√≠vel carregar os logs. Execute 'python proxy_server.py' para usar o servidor proxy local.");
        }

        // Fun√ß√£o para ajustar hor√°rio -3 horas (UTC para hor√°rio de Bras√≠lia)
        function ajustarHorario(dataHora) {
            try {
                // Formato esperado: "2026-01-07 14:30:25" ou "2026-01-07 14:30"
                const [data, hora] = dataHora.split(' ');
                if (!data || !hora) return dataHora;
                
                const [ano, mes, dia] = data.split('-');
                const partesHora = hora.split(':');
                const h = parseInt(partesHora[0]) || 0;
                const m = parseInt(partesHora[1]) || 0;
                const s = parseInt(partesHora[2]) || 0;
                
                // Criar objeto Date (assumindo UTC)
                const dataObj = new Date(Date.UTC(
                    parseInt(ano),
                    parseInt(mes) - 1,
                    parseInt(dia),
                    h,
                    m,
                    s
                ));
                
                // Subtrair 3 horas
                dataObj.setUTCHours(dataObj.getUTCHours() - 3);
                
                // Formatar de volta para o formato original
                const anoAjustado = dataObj.getUTCFullYear();
                const mesAjustado = String(dataObj.getUTCMonth() + 1).padStart(2, '0');
                const diaAjustado = String(dataObj.getUTCDate()).padStart(2, '0');
                const horaAjustada = String(dataObj.getUTCHours()).padStart(2, '0');
                const minAjustado = String(dataObj.getUTCMinutes()).padStart(2, '0');
                const segAjustado = String(dataObj.getUTCSeconds()).padStart(2, '0');
                
                // Retornar no mesmo formato que recebeu (com ou sem segundos)
                if (partesHora.length === 2) {
                    return `${anoAjustado}-${mesAjustado}-${diaAjustado} ${horaAjustada}:${minAjustado}`;
                } else {
                    return `${anoAjustado}-${mesAjustado}-${diaAjustado} ${horaAjustada}:${minAjustado}:${segAjustado}`;
                }
            } catch (e) {
                console.error('Erro ao ajustar hor√°rio:', e);
                return dataHora;
            }
        }

        function formatarLogsHTML(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                return '<span style="color: #ffaa00;">>>> Nenhum evento encontrado</span>';
            }

            let html = '<div style="color: #00ff00;">' + "=".repeat(1) + '</div>';
            let eventos = [];
            let eventoAtual = null;

            for (let i = 0; i < data.length; i++) {
                const log = data[i];
                const msg = log.mensagem.trim();

                if (msg === "==================================================") {
                    if (eventoAtual) {
                        eventos.push(eventoAtual);
                    }
                    // Ajustar hor√°rio ao criar o evento
                    eventoAtual = { data: ajustarHorario(log.data), linhas: [] };
                    continue;
                }

                if (eventoAtual && msg !== "WEBHOOK RECEBIDO!" && 
                    !msg.includes("EVENTO COMPLETO") && 
                    !msg.includes("TIPO DO BODY") &&
                    !msg.includes("DADOS PARSEADOS") &&
                    !msg.includes("DADOS PARA PROCESSAMENTO") &&
                    !msg.includes("VALORES EXTRA√çDOS FINAIS") &&
                    !msg.includes(">>> FORMATO SIMPLES") &&
                    !msg.includes(">>> ID_NEGOCIO ENCONTRADO") &&
                    !msg.includes("DATA CONVERTIDA") &&
                    !msg.includes("OR√áAMENTO CONVERTIDO") &&
                    !msg.startsWith('"') &&
                    !msg.startsWith('{') &&
                    !msg.startsWith('}')) {
                    eventoAtual.linhas.push(msg);
                }
            }

            if (eventoAtual) {
                eventos.push(eventoAtual);
            }

            // Mostrar apenas os 3 √∫ltimos eventos
            const eventosRecentes = eventos.slice(-3);

            eventosRecentes.forEach((evento, idx) => {
                html += `<div style="margin-bottom: 15px;">`;
                html += `<div style="color: #00ffff; font-weight: bold; font-size: 16px;">>> WEBHOOK #${eventos.length - eventosRecentes.length + idx + 1} - ${evento.data}</div>`;
                html += `<div style="color: #00aa00; margin: 5px 0;">${"‚îÄ".repeat(70)}</div>`;

                evento.linhas.forEach(linha => {
                    // Fun√ß√£o auxiliar para limpar valor removendo "(campo: ..."
                    const limparValor = (valor) => {
                        // Remove tudo entre dois pontos e par√™nteses (ex: ": proprietario)", ": data)")
                        // Remove tamb√©m par√™nteses e seu conte√∫do (ex: "(campo: ...)", "(campo")
                        return valor
                            .replace(/\s*:\s*[^)]*\)/gi, '')      // Remove ": qualquercoisa)"
                            .replace(/\s*\([^)]*\)/gi, '')        // Remove "(qualquercoisa)"
                            .replace(/\s*\([^)]*$/gi, '')         // Remove "(qualquercoisa" no final
                            .replace(/\s*\(campo.*$/gi, '')       // Remove "(campo..." no final
                            .trim();
                    };
                    
                    if (linha.startsWith("ID NEG√ìCIO:")) {
                        let valor = linha.split(':')[1].trim();
                        valor = limparValor(valor);
                        html += `<div style="color: #ffff00; font-weight: bold;">  > ID NEG√ìCIO: <span style="color: #ffffff; font-size: 17px;">${valor}</span></div>`;
                    } else if (linha.startsWith("PROPRIET√ÅRIO:")) {
                        let valor = linha.split(':').slice(1).join(':').trim();
                        valor = limparValor(valor);
                        html += `<div style="color: #00ffaa;">  > PROPRIET√ÅRIO: <span style="color: #ffffff;">${valor}</span></div>`;
                    } else if (linha.startsWith("ORGANIZA√á√ÉO:")) {
                        let valor = linha.split(':').slice(1).join(':').trim();
                        valor = limparValor(valor);
                        html += `<div style="color: #00ffaa;">  > ORGANIZA√á√ÉO: <span style="color: #ffffff;">${valor}</span></div>`;
                    } else if (linha.startsWith("TRIBUNAL:")) {
                        let valor = linha.split(':')[1].trim();
                        valor = limparValor(valor);
                        html += `<div style="color: #00ffaa;">  > TRIBUNAL: <span style="color: #ffffff;">${valor}</span></div>`;
                    } else if (linha.startsWith("ID ETAPA:")) {
                        let valor = linha.split(':').slice(1).join(':').trim();
                        valor = limparValor(valor);
                        html += `<div style="color: #aaaaff;">  > ETAPA: <span style="color: #ffffff;">${valor}</span></div>`;
                    } else if (linha.startsWith("OR√áAMENTO:")) {
                        let valor = linha.split(':')[1].trim();
                        valor = limparValor(valor);
                        html += `<div style="color: #ffaa00;">  > OR√áAMENTO: <span style="color: #ffffff; font-weight: bold;">${valor}</span></div>`;
                    } else if (linha.startsWith("DATA:")) {
                        let valor = linha.split(':').slice(1).join(':').trim();
                        // N√ÉO ajustar hor√°rio do campo DATA - manter como est√°
                        valor = limparValor(valor);
                        html += `<div style="color: #aaaaaa;">  > DATA: <span style="color: #ffffff;">${valor}</span></div>`;
                    } else if (linha.includes("SUCESSO")) {
                        html += `<div style="color: #00ff00; font-weight: bold; margin-top: 5px;">  >>> ${linha}</div>`;
                    }
                });

                html += `</div>`;
            });

            html += '<div style="color: #00ff00;">' + "=".repeat(80) + '</div>';
            return html;
        }

        function formatarLogs(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                return "Sem logs nesse per√≠odo";
            }

            let resultado = [];
            let eventoAtual = null;
            let dadosNegocio = null;
            let jaMostrouDados = false;

            // Filtros para mensagens que n√£o queremos mostrar
            const filtrarMensagens = [
                "EVENTO COMPLETO:",
                "TIPO DO BODY:",
                "DADOS PARSEADOS:",
                "DADOS PARA PROCESSAMENTO:",
                "VALORES EXTRA√çDOS FINAIS:",
                ">>> FORMATO SIMPLES DETECTADO",
                ">>> ID_NEGOCIO ENCONTRADO - TENTANDO INSERIR NO BANCO",
                "DATA CONVERTIDA:",
                "OR√áAMENTO CONVERTIDO:",
                '"version":',
                '"routeKey":',
                '"rawPath":',
                '"rawQueryString":',
                '"headers":',
                '"requestContext":',
                '"accountId":',
                '"apiId":',
                '"domainName":',
                '"domainPrefix":',
                '"http":',
                '"method":',
                '"path":',
                '"protocol":',
                '"sourceIp":',
                '"userAgent":',
                '"requestId":',
                '"stage":',
                '"time":',
                '"timeEpoch":',
                '"isBase64Encoded":',
                '"x-amzn-',
                '"content-length":',
                '"content-type":',
                '"accept-encoding":',
                '"accept":',
                '"x-forwarded-',
                '"host":',
                '"{',
                '"}',
                '"},',
                '},',
                '"body":',
                'id_negocio:',
                'proprietario:',
                'data_evento:',
                'id_etapa:',
                'orcamento:',
                'organizacao:',
                'tribunal:',
            ];

            for (let i = 0; i < data.length; i++) {
                const log = data[i];
                const mensagem = log.mensagem.trim();
                const dataHora = log.data;

                // Pular mensagens filtradas
                if (filtrarMensagens.some(filtro => mensagem.includes(filtro))) {
                    continue;
                }

                // Detectar in√≠cio de novo evento
                if (mensagem === "==================================================") {
                    if (eventoAtual && dadosNegocio) {
                        // Mostrar resumo do evento anterior
                        resultado.push(`  ‚úÖ Processado com sucesso!`);
                        resultado.push("");
                    }
                    eventoAtual = dataHora;
                    dadosNegocio = null;
                    jaMostrouDados = false;
                    continue;
                }

                // Detectar WEBHOOK RECEBIDO
                if (mensagem === "WEBHOOK RECEBIDO!") {
                    resultado.push(`\nüì• WEBHOOK RECEBIDO - ${dataHora}`);
                    resultado.push("‚îÄ".repeat(70));
                    continue;
                }

                // Detectar BODY ENCONTRADO (extrair dados do neg√≥cio)
                if (mensagem.startsWith("BODY ENCONTRADO:")) {
                    try {
                        const jsonMatch = mensagem.match(/\{.*\}/);
                        if (jsonMatch) {
                            dadosNegocio = JSON.parse(jsonMatch[0]);
                        }
                    } catch (e) {
                        // Ignorar erro de parse
                    }
                    continue;
                }

                // Detectar informa√ß√µes importantes do neg√≥cio (mostrar apenas uma vez)
                if (!jaMostrouDados && dadosNegocio) {
                    resultado.push(`\n  üìã DADOS DO NEG√ìCIO:`);
                    resultado.push(`     ID: ${dadosNegocio.id_negocio || 'N/A'}`);
                    resultado.push(`     Propriet√°rio: ${dadosNegocio.proprietario || 'N/A'}`);
                    resultado.push(`     Organiza√ß√£o: ${dadosNegocio.organizacao || 'N/A'}`);
                    resultado.push(`     Tribunal: ${dadosNegocio.tribunal || 'N/A'}`);
                    resultado.push(`     Etapa: ${dadosNegocio.id_etapa || 'N/A'}`);
                    resultado.push(`     Or√ßamento: ${dadosNegocio.orcamento || 'N/A'}`);
                    resultado.push(`     Data: ${dadosNegocio.data || 'N/A'}`);
                    jaMostrouDados = true;
                    continue;
                }

                // Detectar informa√ß√µes do neg√≥cio (formato alternativo)
                if (mensagem.startsWith("ID NEG√ìCIO:") || 
                    mensagem.startsWith("PROPRIET√ÅRIO:") ||
                    mensagem.startsWith("ORGANIZA√á√ÉO:") ||
                    mensagem.startsWith("TRIBUNAL:") ||
                    mensagem.startsWith("ID ETAPA:") ||
                    mensagem.startsWith("OR√áAMENTO:") ||
                    mensagem.startsWith("DATA:")) {
                    if (!jaMostrouDados) {
                        // Extrair apenas o valor ap√≥s os dois pontos
                        const valor = mensagem.split(':').slice(1).join(':').trim();
                        const campo = mensagem.split(':')[0].trim();
                        if (!resultado.some(r => r.includes(campo))) {
                            resultado.push(`  ${mensagem}`);
                        }
                    }
                    continue;
                }

                // Detectar sucesso
                if (mensagem.includes("DADOS INSERIDOS NO BANCO COM SUCESSO")) {
                    continue; // J√° mostramos o sucesso no resumo
                }

                // Mostrar outras mensagens importantes (mas n√£o JSON)
                if (mensagem && 
                    !mensagem.startsWith('"') && 
                    !mensagem.endsWith('",') && 
                    !mensagem.endsWith('}') &&
                    !mensagem.startsWith('{') &&
                    mensagem.length > 2 &&
                    !mensagem.match(/^[\s\S]*\{[\s\S]*\}/)) {
                    resultado.push(`  ${mensagem}`);
                }
            }

            // Adicionar resumo do √∫ltimo evento se houver
            if (eventoAtual && dadosNegocio && !jaMostrouDados) {
                resultado.push(`\n  üìã DADOS DO NEG√ìCIO:`);
                resultado.push(`     ID: ${dadosNegocio.id_negocio || 'N/A'}`);
                resultado.push(`     Propriet√°rio: ${dadosNegocio.proprietario || 'N/A'}`);
                resultado.push(`     Organiza√ß√£o: ${dadosNegocio.organizacao || 'N/A'}`);
                resultado.push(`     Tribunal: ${dadosNegocio.tribunal || 'N/A'}`);
                resultado.push(`     Etapa: ${dadosNegocio.id_etapa || 'N/A'}`);
                resultado.push(`     Or√ßamento: ${dadosNegocio.orcamento || 'N/A'}`);
                resultado.push(`     Data: ${dadosNegocio.data || 'N/A'}`);
            }

            if (eventoAtual) {
                resultado.push(`\n  ‚úÖ Processado com sucesso!`);
            }

            return resultado.length > 0 ? resultado.join("\n") : "Sem logs relevantes para exibir";
        }

        // Fun√ß√£o para processar logs de webhooks e gerar resumo para Metas Di√°rias
        function processarLogsMetasDiarias(data) {
            if (!data || !Array.isArray(data)) return '';
            
            let eventos = [];
            let eventoAtual = null;
            
            // Processar logs para extrair eventos de webhook
            for (let i = 0; i < data.length; i++) {
                const log = data[i];
                if (!log || !log.mensagem) continue; // Seguran√ßa
                const msg = log.mensagem.trim();
                
                if (msg === "==================================================") {
                    if (eventoAtual) {
                        eventos.push(eventoAtual);
                    }
                    eventoAtual = { data: ajustarHorario(log.data), linhas: [] };
                    continue;
                }
                
                if (eventoAtual && msg !== "WEBHOOK RECEBIDO!" && 
                    !msg.includes("EVENTO COMPLETO") && 
                    !msg.includes("TIPO DO BODY") &&
                    !msg.includes("DADOS PARSEADOS") &&
                    !msg.includes("DADOS PARA PROCESSAMENTO") &&
                    !msg.includes("VALORES EXTRA√çDOS FINAIS") &&
                    !msg.includes(">>> FORMATO SIMPLES") &&
                    !msg.includes(">>> ID_NEGOCIO ENCONTRADO") &&
                    !msg.includes("DATA CONVERTIDA") &&
                    !msg.includes("OR√áAMENTO CONVERTIDO") &&
                    !msg.startsWith('"') &&
                    !msg.startsWith('{') &&
                    !msg.startsWith('}')) {
                    eventoAtual.linhas.push(msg);
                }
            }
            
            if (eventoAtual) {
                eventos.push(eventoAtual);
            }
            
            // Pegar os √∫ltimos 3 eventos (ou todos se houver menos)
            if (eventos.length === 0) {
                return '> Nenhum evento de neg√≥cio registrado';
            }
            
            // Fun√ß√£o auxiliar para limpar valor
            const limparValor = (valor) => {
                return valor
                    .replace(/\s*:\s*[^)]*\)/gi, '')
                    .replace(/\s*\([^)]*\)/gi, '')
                    .replace(/\s*\([^)]*$/gi, '')
                    .replace(/\s*\(campo.*$/gi, '')
                    .trim();
            };
            
            // Fun√ß√£o para extrair dados de um evento
            const extrairDadosEvento = (evento) => {
                let dados = { hora: evento.data };
                
                evento.linhas.forEach(linha => {
                    if (linha.startsWith("ID NEG√ìCIO:")) {
                        dados.id = limparValor(linha.split(':')[1].trim());
                    } else if (linha.startsWith("PROPRIET√ÅRIO:")) {
                        dados.proprietario = limparValor(linha.split(':').slice(1).join(':').trim());
                    } else if (linha.startsWith("DATA:")) {
                        let valor = linha.split(':').slice(1).join(':').trim();
                        const matchDataHoraCompleta = valor.match(/^(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}(?::\d{2})?)/);
                        
                        if (matchDataHoraCompleta) {
                            valor = matchDataHoraCompleta[1];
                        } else {
                            valor = limparValor(valor);
                            const matchDataHora = valor.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{2})$/);
                            if (matchDataHora) {
                                valor = `${matchDataHora[1]} ${matchDataHora[2]}:00`;
                            }
                        }
                        dados.data = valor;
                    } else if (linha.startsWith("ID ETAPA:")) {
                        dados.etapa = limparValor(linha.split(':').slice(1).join(':').trim());
                    } else if (linha.startsWith("OR√áAMENTO:")) {
                        dados.orcamento = limparValor(linha.split(':')[1].trim());
                    } else if (linha.startsWith("ORGANIZA√á√ÉO:")) {
                        dados.organizacao = limparValor(linha.split(':').slice(1).join(':').trim());
                    } else if (linha.startsWith("TRIBUNAL:")) {
                        dados.tribunal = limparValor(linha.split(':')[1].trim());
                    }
                });
                
                return dados;
            };
            
            // Filtrar apenas eventos que t√™m dados (pelo menos ID ou Propriet√°rio)
            const eventosComDados = eventos.filter(evento => {
                return evento.linhas.some(linha => 
                    linha.startsWith("ID NEG√ìCIO:") || 
                    linha.startsWith("PROPRIET√ÅRIO:") ||
                    linha.includes(">>> DADOS INSERIDOS NO BANCO COM SUCESSO!")
                );
            });
            
            // Pegar os √∫ltimos 7 eventos (fixo)
            const ultimosEventos = eventosComDados.slice(-7);
            
            // Construir resumo em formato compacto
            let resumo = [];
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            resumo.push('> [1] METAS DIARIAS - ULTIMOS 7');
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            
            // Inverter para mostrar o mais recente embaixo (como terminal real)
            ultimosEventos.reverse().forEach((evento, index) => {
                const d = extrairDadosEvento(evento);
                
                resumo.push('');
                
                // Linha 1: Hora | ID | Propriet√°rio
                const hora = d.hora ? d.hora.substring(11) : 'N/A';
                const id = d.id || 'N/A';
                const prop = d.proprietario || 'N/A';
                resumo.push(`> [${hora}] ID:${id} | ${prop}`);
                
                // Linha 2: Data | Etapa | Or√ßamento
                const dataEvento = d.data || 'N/A';
                const etapa = d.etapa || 'N/A';
                const orcamento = d.orcamento || 'N/A';
                resumo.push(`> ${dataEvento} | ${etapa} | ${orcamento}`);
                
                // Linha 3: Organiza√ß√£o | Tribunal
                const org = d.organizacao || 'N/A';
                const trib = d.tribunal || 'N/A';
                resumo.push(`> ${org} | ${trib}`);
                
                // Separador entre eventos (exceto no √∫ltimo)
                if (index < ultimosEventos.length - 1) {
                    resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                }
            });
            
            resumo.push('');
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            
            return resumo.join('\n');
        }

        // Fun√ß√£o para processar logs de movimentacoesWilliam e gerar resumo
        function processarLogsMovimentacoes(data) {
            if (!data || !Array.isArray(data)) return '';
            
            // Filtrar apenas logs de movimentacoesWilliam
            const logsMovimentacoes = data.filter(log => log && log.origem === 'movimentacoesWilliam');
            
            if (logsMovimentacoes.length === 0) {
                return '> Nenhuma opera√ß√£o de movimenta√ß√µes registrada';
            }
            
            // Extrair informa√ß√µes-chave dos logs
            let statusDownload = null;
            let tabelaUsada = null;
            let totalRegistros = null;
            let municipiosBanco = null;
            let statusMigracao = null;
            let registrosInseridos = null;
            let ultimaAtualizacao = null;
            
            logsMovimentacoes.forEach(log => {
                if (!log || !log.mensagem) return; // Seguran√ßa
                const msg = log.mensagem.replace(/[üîçüìäüì•üîó‚úÖ‚ùå‚ö†Ô∏èüíæ]/g, '').trim();
                
                if (msg.includes('Download conclu√≠do')) {
                    statusDownload = 'Conclu√≠do';
                }
                if (msg.includes('Usando tabela:')) {
                    tabelaUsada = msg.split(':')[1]?.trim();
                }
                if (msg.includes('Total de registros:')) {
                    totalRegistros = msg.split(':')[1]?.trim();
                }
                if (msg.includes('Munic√≠pios no banco de dados:')) {
                    municipiosBanco = msg.split(':')[1]?.trim();
                }
                if (msg.includes('Migra√ß√£o conclu√≠da')) {
                    statusMigracao = 'Conclu√≠da';
                }
                if (msg.includes('Registros inseridos:')) {
                    registrosInseridos = msg.split(':')[1]?.trim();
                }
                
                ultimaAtualizacao = ajustarHorario(log.data);
            });
            
            // Construir resumo
            let resumo = [];
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            resumo.push('> [2] SALDO EM CONTA');
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            resumo.push('');
            
            if (statusDownload) {
                resumo.push(`> DOWNLOAD: ${statusDownload}`);
            }
            
            if (tabelaUsada) {
                resumo.push(`> TABELA: ${tabelaUsada}`);
            }
            
            if (totalRegistros) {
                resumo.push(`> TOTAL DE REGISTROS: ${totalRegistros}`);
            }
            
            if (municipiosBanco) {
                resumo.push(`> MUNICIPIOS NO BANCO: ${municipiosBanco}`);
            }
            
            if (statusMigracao) {
                resumo.push(`> MIGRACAO: ${statusMigracao}`);
            }
            
            if (registrosInseridos) {
                resumo.push(`> REGISTROS INSERIDOS: ${registrosInseridos}`);
            }
            
            if (ultimaAtualizacao) {
                resumo.push('');
                resumo.push(`> ULTIMA ATUALIZACAO: ${ultimaAtualizacao}`);
            }
            
            resumo.push('');
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            
            return resumo.join('\n');
        }

        // Fun√ß√£o para processar logs de filtrar_discador_e_salvar_no_banco
        function processarLogsDiscador(data) {
            if (!data || !Array.isArray(data)) return '';
            
            // Dicion√°rios de STATUS e QUALIFICA√á√ÉO
            const statusMap = {
                5: 'N√£o atendida',
                6: 'Abandonada',
                7: 'Finalizada',
                8: 'Falha',
                9: 'CP p√≥s',
                15: 'CP pr√©'
            };
            
            const qualificacaoMap = {
                '-3': 'Caixa postal',
                '-2': 'N√£o qualificado',
                '127117': 'Retorno manual',
                '127216': 'Gest√£o verificar',
                '127218': 'Aceitou proposta',
                '127219': 'N√£o aceitou proposta',
                '127220': 'Conhecido passou',
                '127221': 'Conhecido n√£o passou',
                '127222': 'Retorno para campanha',
                '127223': 'N√∫mero errado',
                '130654': 'Quer negociar',
                '130657': 'N√∫mero errado estagnadas'
            };
            
            // Filtrar apenas logs de filtrar_discador_e_salvar_no_banco
            const logsDiscador = data.filter(log => log && log.origem === 'filtrar_discador_e_salvar_no_banco');
            
            if (logsDiscador.length === 0) {
                return '> Nenhuma opera√ß√£o de discador registrada';
            }
            
            // Procurar pelos √öLTIMOS 10 logs (fixo) - sem duplicatas
            let ultimosLogs = [];
            let logsVistos = new Set(); // Para rastrear duplicatas
            
            for (let i = logsDiscador.length - 1; i >= 0 && ultimosLogs.length < 10; i--) {
                const log = logsDiscador[i];
                if (!log || !log.mensagem) continue; // Seguran√ßa
                const mensagem = log.mensagem.trim();
                
                // Procurar por logs com dicion√°rio Python (que cont√©m os dados)
                if (mensagem.startsWith('{') && mensagem.includes('numero') && mensagem.includes('status')) {
                    try {
                        // Converter dicion√°rio Python para JSON
                        let jsonStr = mensagem
                            .replace(/'/g, '"')
                            .replace(/None/g, 'null')
                            .replace(/False/g, 'false')
                            .replace(/True/g, 'true');
                        
                        // Tentar parsear
                        const dadosDiscador = JSON.parse(jsonStr);
                        const hora = ajustarHorario(log.data);
                        
                        // Criar chave √∫nica para detectar duplicatas
                        const chaveUnica = `${hora}_${dadosDiscador.numero}_${dadosDiscador.campanha}_${dadosDiscador.status}`;
                        
                        // Verificar se j√° foi adicionado
                        if (!logsVistos.has(chaveUnica)) {
                            logsVistos.add(chaveUnica);
                            ultimosLogs.unshift({
                                dados: dadosDiscador,
                                hora: hora
                            });
                        }
                    } catch (e) {
                        // Se falhar, tentar limpar caracteres problem√°ticos
                        try {
                            let jsonStr2 = mensagem
                                .replace(/'/g, '"')
                                .replace(/None/g, 'null')
                                .replace(/False/g, 'false')
                                .replace(/True/g, 'true')
                                .replace(/[\u0080-\uFFFF]/g, (match) => {
                                    return match;
                                });
                            
                            const dadosDiscador = JSON.parse(jsonStr2);
                            const hora = ajustarHorario(log.data);
                            
                            // Criar chave √∫nica para detectar duplicatas
                            const chaveUnica = `${hora}_${dadosDiscador.numero}_${dadosDiscador.campanha}_${dadosDiscador.status}`;
                            
                            // Verificar se j√° foi adicionado
                            if (!logsVistos.has(chaveUnica)) {
                                logsVistos.add(chaveUnica);
                                ultimosLogs.unshift({
                                    dados: dadosDiscador,
                                    hora: hora
                                });
                            }
                        } catch (e2) {
                            // Continuar procurando
                            continue;
                        }
                    }
                }
            }
            
            // Construir resumo
            let resumo = [];
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            resumo.push('> [3] DISCADOR - ULTIMOS 10');
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            
            if (ultimosLogs.length > 0) {
                // Inverter para mostrar o mais recente embaixo (como terminal real)
                ultimosLogs.reverse();
                
                // Mostrar os 5 √∫ltimos logs em formato compacto
                ultimosLogs.forEach((logItem, index) => {
                    const d = logItem.dados;
                    const hora = logItem.hora.substring(11); // Apenas HH:MM:SS
                    
                    resumo.push('');
                    
                    // Linha 1: Hora | N√∫mero | Campanha
                    const numero = d.numero || 'N/A';
                    const campanha = d.campanha || 'N/A';
                    resumo.push(`> [${hora}] ${numero} | ${campanha}`);
                    
                    // Linha 2: Agente | Status | Qual | Tempo | Modo
                    const agente = d.agente || 'Sistema';
                    const status = d.status !== undefined ? (statusMap[d.status] || `St${d.status}`) : 'N/A';
                    
                    let qual = 'Sem qual';
                    if (d.qualificacao !== undefined && d.qualificacao !== null) {
                        const qualId = String(d.qualificacao);
                        qual = qualificacaoMap[qualId] || `Q${qualId}`;
                    }
                    
                    const tempo = d.tempo_da_ligacao !== undefined ? `${d.tempo_da_ligacao}s` : '0s';
                    const modo = d.modo ? d.modo.toUpperCase() : 'N/A';
                    
                    resumo.push(`> ${agente} | ${status} | ${qual} | ${tempo} | ${modo}`);
                    
                    // Separador entre logs (exceto no √∫ltimo)
                    if (index < ultimosLogs.length - 1) {
                        resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                    }
                });
            } else {
                // Se n√£o conseguiu parsear, tentar mostrar o √∫ltimo log ao menos
                const ultimoLog = logsDiscador[logsDiscador.length - 1];
                if (ultimoLog) {
                    const mensagem = ultimoLog.mensagem.replace(/[üîçüìäüì•üîó‚úÖ‚ùå‚ö†Ô∏èüíÄüëÇüëÉ]/g, '').trim();
                    resumo.push('> Dados do ultimo log:');
                    resumo.push('');
                    
                    // Tentar extrair informa√ß√µes b√°sicas com regex
                    const numeroMatch = mensagem.match(/'numero':\s*'([^']+)'/);
                    const campanhaMatch = mensagem.match(/'campanha':\s*'([^']+)'/);
                    const agenteMatch = mensagem.match(/'agente':\s*'([^']+)'/);
                    const statusMatch = mensagem.match(/'status':\s*(\d+)/);
                    const qualificacaoMatch = mensagem.match(/'qualificacao':\s*(-?\d+)/);
                    const tempoMatch = mensagem.match(/'tempo_da_ligacao':\s*(\d+)/);
                    const modoMatch = mensagem.match(/'modo':\s*'([^']+)'/);
                    
                    if (numeroMatch) resumo.push(`> NUMERO: ${numeroMatch[1]}`);
                    if (campanhaMatch) resumo.push(`> CAMPANHA: ${campanhaMatch[1]}`);
                    
                    if (agenteMatch && agenteMatch[1] !== 'None') {
                        resumo.push(`> AGENTE: ${agenteMatch[1]}`);
                    } else {
                        resumo.push(`> AGENTE: Sistema`);
                    }
                    
                    if (statusMatch) {
                        const statusTexto = statusMap[parseInt(statusMatch[1])] || `Status ${statusMatch[1]}`;
                        resumo.push(`> STATUS: ${statusTexto}`);
                    }
                    
                    if (qualificacaoMatch && qualificacaoMatch[1] !== 'None') {
                        const qualId = qualificacaoMatch[1];
                        const qualificacaoTexto = qualificacaoMap[qualId] || `Qualificacao ${qualId}`;
                        resumo.push(`> QUALIFICACAO: ${qualificacaoTexto}`);
                    } else {
                        resumo.push(`> QUALIFICACAO: Sem qualificacao`);
                    }
                    
                    if (tempoMatch) resumo.push(`> TEMPO DE LIGACAO: ${tempoMatch[1]}s`);
                    if (modoMatch) resumo.push(`> MODO: ${modoMatch[1].toUpperCase()}`);
                }
            }
            
            resumo.push('');
            resumo.push('> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            
            return resumo.join('\n');
        }



// Flag para controlar primeira carga
        let primeiraCarga = true;
        let ultimoConteudoLogs = '';
        let ultimoConteudoTerminal = '';
        let ultimoConteudoTerminal2 = '';

        // Fun√ß√£o auxiliar para normalizar conte√∫do (remove espa√ßos extras e normaliza quebras de linha)
        function normalizarConteudo(texto) {
            return texto.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
        }

        async function carregarLogs() {
            const logsEl = document.getElementById('logs');
            const terminalEl = document.getElementById('terminal');
            const terminal2El = document.getElementById('terminal2');
            
            // S√≥ mostra "Carregando..." na primeira vez
            if (logsEl && primeiraCarga) {
                logsEl.textContent = ">>> Carregando dados do sistema...\n>>> Conectando ao servidor...\n>>> Aguarde...";
                ultimoConteudoLogs = logsEl.textContent;
            }

            try {
                const data = await fazerRequisicao(API_FALLBACK);
                
                if (data && Array.isArray(data) && data.length > 0) {
                    // Processar logs de webhooks e atualizar terminal "Metas Di√°rias"
                    if (logsEl) {
                        const resumoMetas = processarLogsMetasDiarias(data);
                        const novoConteudo = resumoMetas || '> Nenhum evento de neg√≥cio registrado';
                        const novoConteudoNormalizado = normalizarConteudo(novoConteudo);
                        const conteudoAtualNormalizado = normalizarConteudo(logsEl.textContent);
                        
                        // S√≥ atualiza se o conte√∫do realmente mudou (evita piscar)
                        if (novoConteudoNormalizado !== conteudoAtualNormalizado && novoConteudoNormalizado !== ultimoConteudoLogs) {
                            requestAnimationFrame(() => {
                                // Remove classes que alteram a cor para garantir cor consistente
                                logsEl.classList.remove("loading", "error", "empty");
                                logsEl.textContent = novoConteudo;
                                ultimoConteudoLogs = novoConteudoNormalizado;
                            });
                        }
                    }
                    
                    // Processar logs de movimentacoesWilliam e atualizar terminal "Saldo em Conta"
                    if (terminalEl) {
                        const resumoMovimentacoes = processarLogsMovimentacoes(data);
                        const novoConteudoTerminal = resumoMovimentacoes || '> Nenhuma opera√ß√£o de movimenta√ß√µes registrada';
                        const novoConteudoTerminalNormalizado = normalizarConteudo(novoConteudoTerminal);
                        const conteudoAtualTerminalNormalizado = normalizarConteudo(terminalEl.textContent);
                        
                        // S√≥ atualiza se o conte√∫do realmente mudou (evita piscar)
                        if (novoConteudoTerminalNormalizado !== conteudoAtualTerminalNormalizado && novoConteudoTerminalNormalizado !== ultimoConteudoTerminal) {
                            requestAnimationFrame(() => {
                                // Remove classes que alteram a cor para garantir cor consistente
                                terminalEl.classList.remove("loading", "error", "empty");
                                terminalEl.textContent = novoConteudoTerminal;
                                ultimoConteudoTerminal = novoConteudoTerminalNormalizado;
                            });
                        }
                    }
                    
                    // Processar logs de filtrar_discador_e_salvar_no_banco e atualizar terminal 3
                    if (terminal2El) {
                        const resumoDiscador = processarLogsDiscador(data);
                        const novoConteudoTerminal2 = resumoDiscador || '> Nenhuma opera√ß√£o de discador registrada';
                        const novoConteudoTerminal2Normalizado = normalizarConteudo(novoConteudoTerminal2);
                        const conteudoAtualTerminal2Normalizado = normalizarConteudo(terminal2El.textContent);
                        
                        // S√≥ atualiza se o conte√∫do realmente mudou (evita piscar)
                        if (novoConteudoTerminal2Normalizado !== conteudoAtualTerminal2Normalizado && novoConteudoTerminal2Normalizado !== ultimoConteudoTerminal2) {
                            requestAnimationFrame(() => {
                                // Remove classes que alteram a cor para garantir cor consistente
                                terminal2El.classList.remove("loading", "error", "empty");
                                terminal2El.textContent = novoConteudoTerminal2;
                                ultimoConteudoTerminal2 = novoConteudoTerminal2Normalizado;
                            });
                        }
                    }
                } else {
                    if (logsEl) {
                        const msgVazio = '> Nenhum evento registrado 10 minutos atr√°s.\n> STATUS: Aguardando novos eventos...\n> Pressione [F5] para atualizar.';
                        const msgVazioNormalizado = normalizarConteudo(msgVazio);
                        const conteudoAtualNormalizado = normalizarConteudo(logsEl.textContent);
                        
                        if (msgVazioNormalizado !== conteudoAtualNormalizado && msgVazioNormalizado !== ultimoConteudoLogs) {
                            requestAnimationFrame(() => {
                                // Remove classes que alteram a cor para garantir cor consistente
                                logsEl.classList.remove("loading", "error", "empty");
                                logsEl.textContent = msgVazio;
                                ultimoConteudoLogs = msgVazioNormalizado;
                            });
                        }
                    }
                    if (terminalEl) {
                        const msgVazioTerminal = '> Nenhuma opera√ß√£o de movimenta√ß√µes registrada';
                        const msgVazioTerminalNormalizado = normalizarConteudo(msgVazioTerminal);
                        const conteudoAtualTerminalNormalizado = normalizarConteudo(terminalEl.textContent);
                        
                        if (msgVazioTerminalNormalizado !== conteudoAtualTerminalNormalizado && msgVazioTerminalNormalizado !== ultimoConteudoTerminal) {
                            requestAnimationFrame(() => {
                                // Remove classes que alteram a cor para garantir cor consistente
                                terminalEl.classList.remove("loading", "error", "empty");
                                terminalEl.textContent = msgVazioTerminal;
                                ultimoConteudoTerminal = msgVazioTerminalNormalizado;
                            });
                        }
                    }
                    if (terminal2El) {
                        const msgVazioTerminal2 = '> Nenhuma opera√ß√£o de discador registrada';
                        const msgVazioTerminal2Normalizado = normalizarConteudo(msgVazioTerminal2);
                        const conteudoAtualTerminal2Normalizado = normalizarConteudo(terminal2El.textContent);
                        
                        if (msgVazioTerminal2Normalizado !== conteudoAtualTerminal2Normalizado && msgVazioTerminal2Normalizado !== ultimoConteudoTerminal2) {
                            requestAnimationFrame(() => {
                                // Remove classes que alteram a cor para garantir cor consistente
                                terminal2El.classList.remove("loading", "error", "empty");
                                terminal2El.textContent = msgVazioTerminal2;
                                ultimoConteudoTerminal2 = msgVazioTerminal2Normalizado;
                            });
                        }
                    }
                }
                
                // Marca que a primeira carga foi conclu√≠da
                primeiraCarga = false;
            } catch (err) {
                if (logsEl) {
                    let mensagemErro = ">>> ERRO CRITICO: Falha na comunicacao com o servidor\n";
                    mensagemErro += ">>> " + "=".repeat(74) + "\n\n";
                    
                    if (err.message.includes("Failed to fetch") || err.message.includes("NetworkError")) {
                        mensagemErro += ">>> DIAGNOSTICO:\n";
                        mensagemErro += ">>>   - Problema de conexao detectado\n";
                        mensagemErro += ">>>   - Servidor pode estar offline\n";
                        mensagemErro += ">>>   - Firewall bloqueando requisicao\n\n";
                        mensagemErro += ">>> ACOES RECOMENDADAS:\n";
                        mensagemErro += ">>>   1. Verificar conexao de rede\n";
                        mensagemErro += ">>>   2. Contatar administrador do sistema\n";
                        mensagemErro += ">>>   3. Pressionar [F5] para tentar novamente\n";
                    } else {
                        mensagemErro += `>>> DETALHES: ${err.message}\n`;
                        mensagemErro += ">>> Pressione [F5] para tentar novamente\n";
                    }
                    
                    mensagemErro += "\n>>> " + "=".repeat(74);
                    
                    const mensagemErroNormalizada = normalizarConteudo(mensagemErro);
                    const conteudoAtualNormalizado = normalizarConteudo(logsEl.textContent);
                    
                    // S√≥ atualiza se o conte√∫do mudou (evita piscar)
                    if (mensagemErroNormalizada !== conteudoAtualNormalizado && mensagemErroNormalizada !== ultimoConteudoLogs) {
                        requestAnimationFrame(() => {
                            logsEl.classList.remove("loading");
                            logsEl.classList.add("error");
                            logsEl.textContent = mensagemErro;
                            ultimoConteudoLogs = mensagemErroNormalizada;
                        });
                    }
                }
                
                if (terminalEl) {
                    const msgErroTerminal = "> ERRO: Falha ao carregar dados de movimenta√ß√µes.";
                    const msgErroTerminalNormalizada = normalizarConteudo(msgErroTerminal);
                    const conteudoAtualTerminalNormalizado = normalizarConteudo(terminalEl.textContent);
                    
                    if (msgErroTerminalNormalizada !== conteudoAtualTerminalNormalizado && msgErroTerminalNormalizada !== ultimoConteudoTerminal) {
                        requestAnimationFrame(() => {
                            terminalEl.classList.remove("loading");
                            terminalEl.classList.add("error");
                            terminalEl.textContent = msgErroTerminal;
                            ultimoConteudoTerminal = msgErroTerminalNormalizada;
                        });
                    }
                }
                
                if (terminal2El) {
                    const msgErroTerminal2 = "> ERRO: Falha ao carregar dados de discador.";
                    const msgErroTerminal2Normalizada = normalizarConteudo(msgErroTerminal2);
                    const conteudoAtualTerminal2Normalizado = normalizarConteudo(terminal2El.textContent);
                    
                    if (msgErroTerminal2Normalizada !== conteudoAtualTerminal2Normalizado && msgErroTerminal2Normalizada !== ultimoConteudoTerminal2) {
                        requestAnimationFrame(() => {
                            terminal2El.classList.remove("loading");
                            terminal2El.classList.add("error");
                            terminal2El.textContent = msgErroTerminal2;
                            ultimoConteudoTerminal2 = msgErroTerminal2Normalizada;
                        });
                    }
                }
                
                console.error("Erro completo:", err);
                primeiraCarga = false;
            }
        }

        // Fun√ß√£o auxiliar para rolagem autom√°tica
        function rolarParaFinal() {
            const logsEl = document.getElementById('logs');
            if (logsEl) {
                // M√∫ltiplas tentativas para garantir rolagem
                setTimeout(() => {
                    logsEl.scrollTop = logsEl.scrollHeight;
                    atualizarScrollbarCustomizada();
                }, 50);
                setTimeout(() => {
                    logsEl.scrollTo({
                        top: logsEl.scrollHeight,
                        behavior: 'smooth'
                    });
                    atualizarScrollbarCustomizada();
                }, 200);
                setTimeout(() => {
                    logsEl.scrollTop = logsEl.scrollHeight;
                    atualizarScrollbarCustomizada();
                }, 500);
            }
        }

        // Observador para detectar mudan√ßas no conte√∫do e rolar automaticamente
        const logsObserver = new MutationObserver(() => {
            rolarParaFinal();
        });

        // Iniciar observa√ß√£o quando o elemento estiver dispon√≠vel
        setTimeout(() => {
            const logsEl = document.getElementById('logs');
            if (logsEl) {
                logsObserver.observe(logsEl, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            }
        }, 500);

        // Fun√ß√£o para for√ßar estilos de scrollbar - Abordagem mais agressiva
        function aplicarEstilosScrollbar() {
            // Criar e injetar estilos dinamicamente
            const styleId = 'custom-scrollbar-styles';
            if (document.getElementById(styleId)) {
                return; // J√° foi aplicado
            }
            
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                /* Estilos de scrollbar customizados - M√°xima prioridade */
                #logs::-webkit-scrollbar {
                    width: 14px !important;
                    height: 14px !important;
                    background-color: #000000 !important;
                    border-left: 3px solid #003300 !important;
                }
                #logs::-webkit-scrollbar-track {
                    background: #000000 !important;
                    border-left: 3px solid #003300 !important;
                    box-shadow: inset 0 0 10px rgba(0, 51, 0, 1) !important;
                }
                #logs::-webkit-scrollbar-thumb {
                    background: #00ff00 !important;
                    background-image: linear-gradient(180deg, #00ff00 0%, #00aa00 50%, #00ff00 100%) !important;
                    border-radius: 7px !important;
                    border: 2px solid #003300 !important;
                    box-shadow: 
                        0 0 15px rgba(0, 255, 0, 1) !important,
                        inset 0 0 8px rgba(0, 255, 0, 0.5) !important,
                        0 0 25px rgba(0, 255, 0, 0.4) !important;
                    min-height: 50px !important;
                }
                #logs::-webkit-scrollbar-thumb:hover {
                    background: #00ff00 !important;
                    background-image: linear-gradient(180deg, #00ff00 0%, #00ff00 50%, #00ff00 100%) !important;
                    box-shadow: 
                        0 0 25px rgba(0, 255, 0, 1.2) !important,
                        inset 0 0 12px rgba(0, 255, 0, 0.8) !important,
                        0 0 40px rgba(0, 255, 0, 0.6) !important;
                    border-color: #00ff00 !important;
                }
                #logs::-webkit-scrollbar-thumb:active {
                    background: #00ff00 !important;
                    box-shadow: 
                        0 0 30px rgba(0, 255, 0, 1.5) !important,
                        inset 0 0 15px rgba(0, 255, 0, 1) !important,
                        0 0 50px rgba(0, 255, 0, 0.8) !important;
                }
                #terminal::-webkit-scrollbar,
                .terminal-output::-webkit-scrollbar {
                    width: 14px !important;
                    height: 14px !important;
                    background-color: #000000 !important;
                    border-left: 3px solid #003300 !important;
                }
                #terminal::-webkit-scrollbar-track,
                .terminal-output::-webkit-scrollbar-track {
                    background: #000000 !important;
                    border-left: 3px solid #003300 !important;
                    box-shadow: inset 0 0 10px rgba(0, 51, 0, 1) !important;
                }
                #terminal::-webkit-scrollbar-thumb,
                .terminal-output::-webkit-scrollbar-thumb {
                    background: #00ff00 !important;
                    background-image: linear-gradient(180deg, #00ff00 0%, #00aa00 50%, #00ff00 100%) !important;
                    border-radius: 7px !important;
                    border: 2px solid #003300 !important;
                    box-shadow: 
                        0 0 15px rgba(0, 255, 0, 1) !important,
                        inset 0 0 8px rgba(0, 255, 0, 0.5) !important,
                        0 0 25px rgba(0, 255, 0, 0.4) !important;
                    min-height: 50px !important;
                }
                #terminal::-webkit-scrollbar-thumb:hover,
                .terminal-output::-webkit-scrollbar-thumb:hover {
                    background: #00ff00 !important;
                    background-image: linear-gradient(180deg, #00ff00 0%, #00ff00 50%, #00ff00 100%) !important;
                    box-shadow: 
                        0 0 25px rgba(0, 255, 0, 1.2) !important,
                        inset 0 0 12px rgba(0, 255, 0, 0.8) !important,
                        0 0 40px rgba(0, 255, 0, 0.6) !important;
                    border-color: #00ff00 !important;
                }
            `;
            document.head.appendChild(style);
            
            // For√ßar reflow para aplicar estilos
            const logsEl = document.getElementById('logs');
            if (logsEl) {
                logsEl.style.display = 'none';
                logsEl.offsetHeight; // Trigger reflow
                logsEl.style.display = '';
            }
        }

        // Aplicar estilos quando a p√°gina carregar
        window.addEventListener('DOMContentLoaded', aplicarEstilosScrollbar);
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', aplicarEstilosScrollbar);
        } else {
            aplicarEstilosScrollbar();
        }

        // Carregar logs ao carregar a p√°gina
        carregarLogs();

        // Auto-refresh com intervalo aleat√≥rio entre 20-60 segundos
        let autoRefreshTimeout;
        let countdownInterval;
        let countdown = 20;
        let proximoRefresh = 20;
        
        function getRandomInterval() {
            // Retorna um valor aleat√≥rio entre 20 e 60 segundos (em ms)
            return (Math.floor(Math.random() * (60 - 20 + 1)) + 20) * 1000;
        }
        
        function agendarProximoRefresh() {
            // Limpa timeout anterior se existir
            if (autoRefreshTimeout) {
                clearTimeout(autoRefreshTimeout);
            }
            
            // Gera intervalo aleat√≥rio
            const intervalo = getRandomInterval();
            proximoRefresh = Math.floor(intervalo / 1000);
            countdown = proximoRefresh;
            
            // Agenda pr√≥ximo refresh
            autoRefreshTimeout = setTimeout(() => {
                carregarLogs();
                agendarProximoRefresh(); // Agenda o pr√≥ximo
            }, intervalo);
        }
        
        function iniciarAutoRefresh() {
            // Limpa intervalos anteriores se existirem
            if (autoRefreshTimeout) {
                clearTimeout(autoRefreshTimeout);
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Atualiza imediatamente
            carregarLogs();
            
            // Agenda pr√≥ximo refresh com intervalo aleat√≥rio
            agendarProximoRefresh();

            // Atualiza contador visual a cada segundo
            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    countdown = proximoRefresh;
                }
                document.getElementById('autoRefreshStatus').textContent = `[‚Üª ${countdown}s]`;
            }, 1000);
        }

        // Inicia auto-refresh
        iniciarAutoRefresh();

        // Atalho F5 para atualizar manualmente
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F5' || e.keyCode === 116) {
                e.preventDefault();
                countdown = 10; // Reseta contador
                carregarLogs();
            }
        });

        // Fun√ß√£o para abrir dashboard em tela cheia em nova aba
        function abrirFullscreen(url) {
            window.open(url, '_blank', 'noopener,noreferrer');
        }

        // Barra de rolagem customizada (scroll autom√°tico agora √© via CSS)

        // Fun√ß√£o mantida para compatibilidade, mas n√£o √© mais necess√°ria com CSS animations
        function atualizarScrollbarCustomizada() {
            // Scroll agora √© feito via CSS, n√£o precisa mais atualizar barra
        }

        // Scroll autom√°tico agora √© feito via CSS animations
        // N√£o precisa mais de JavaScript para isso
    </script>
</body>
</html>

